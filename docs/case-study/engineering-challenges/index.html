<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=stylesheet type=text/css href=asciinema-player.css><link rel=preload as=font href=https://otter-framework.dev/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://otter-framework.dev/fonts/vendor/jost/jost-v4-latin-500.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://otter-framework.dev/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><link rel=stylesheet href=https://otter-framework.dev/main.1ceb5f88fb530d1461e4698b552b7a51a501d32f8035086019853dfa4fd27db3127d1d9e22723bb66a97841e85b8eacb1b23763bbf9f3322bd3b001aaf8f4d87.css integrity="sha512-HOtfiPtTDRRh5GmLVSt6UaUB0y+ANQhgGYU9+k/SfbMSfR2eInI7tmqXhB6FuOrLGyN2O7+fMyK9OwAar49Nhw==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>Engineering Challenges - Otter</title><meta name=description content="The following is an in-depth discussion of 4 interesting engineering challenges we faced while building Otter.
WebRTC and Glare #One challenge we faced working with the WebRTC API involved asynchronicity and race conditions. Ideally, the offer-answer process happens in an orderly fashion: one peer sends an offer, the other peer receives it and sends back an answer (if the other peer wishes to establish a P2P connection).
In practice, however, both peers can end up firing offers to each other in a haphazard fashion."><link rel=canonical href=https://otter-framework.dev/docs/case-study/engineering-challenges/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="Engineering Challenges"><meta property="og:description" content="The following is an in-depth discussion of 4 interesting engineering challenges we faced while building Otter.
WebRTC and Glare #One challenge we faced working with the WebRTC API involved asynchronicity and race conditions. Ideally, the offer-answer process happens in an orderly fashion: one peer sends an offer, the other peer receives it and sends back an answer (if the other peer wishes to establish a P2P connection).
In practice, however, both peers can end up firing offers to each other in a haphazard fashion."><meta property="og:url" content="https://otter-framework.dev/docs/case-study/engineering-challenges/"><meta property="og:site_name" content="Otter"><meta property="article:published_time" content="2020-10-06T08:48:57+00:00"><meta property="article:modified_time" content="2020-10-06T08:48:57+00:00"><meta property="og:image" content="https://otter-framework.dev/doks.png"><meta property="og:image:alt" content="Otter"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content="@getdoks"><meta name=twitter:creator content="@henkverlinde"><meta name=twitter:title content="Engineering Challenges"><meta name=twitter:description content><meta name=twitter:image content="https://otter-framework.dev/doks.png"><meta name=twitter:image:alt content="Engineering Challenges"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://otter-framework.dev/#/schema/organization/1","name":"Doks","url":"https://otter-framework.dev/","sameAs":["https://twitter.com/getdoks","https://github.com/h-enk/doks"],"logo":{"@type":"ImageObject","@id":"https://otter-framework.dev/#/schema/image/1","url":"https://otter-framework.dev/logo-doks.png","width":512,"height":512,"caption":"Doks"},"image":{"@id":"https://otter-framework.dev/#/schema/image/1"}},{"@type":"WebSite","@id":"https://otter-framework.dev/#/schema/website/1","url":"https://otter-framework.dev/","name":"Otter","description":"Otter is a drop-in solution that facilitates peer-to-peer video communication within web applications.","publisher":{"@id":"https://otter-framework.dev/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://otter-framework.dev/docs/case-study/engineering-challenges/","url":"https://otter-framework.dev/docs/case-study/engineering-challenges/","name":"Engineering Challenges","description":"","isPartOf":{"@id":"https://otter-framework.dev/#/schema/website/1"},"about":{"@id":"https://otter-framework.dev/#/schema/organization/1"},"datePublished":"2020-10-06T08:48:57CET","dateModified":"2020-10-06T08:48:57CET","breadcrumb":{"@id":"https://otter-framework.dev/docs/case-study/engineering-challenges/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://otter-framework.dev/docs/case-study/engineering-challenges/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://otter-framework.dev/docs/case-study/engineering-challenges/"]}]},{"@type":"BreadcrumbList","@id":"https://otter-framework.dev/docs/case-study/engineering-challenges/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://otter-framework.dev/","url":"https://otter-framework.dev/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://otter-framework.dev/docs/","url":"https://otter-framework.dev/docs/","name":"Docs"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://otter-framework.dev/docs/case-study/","url":"https://otter-framework.dev/docs/case-study/","name":"Case Study"}},{"@type":"ListItem","position":4,"item":{"@id":"https://otter-framework.dev/docs/case-study/engineering-challenges/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"Article","@id":"https://otter-framework.dev/#/schema/article/1","headline":"Engineering Challenges","description":"","isPartOf":{"@id":"https://otter-framework.dev/docs/case-study/engineering-challenges/"},"mainEntityOfPage":{"@id":"https://otter-framework.dev/docs/case-study/engineering-challenges/"},"datePublished":"2020-10-06T08:48:57CET","dateModified":"2020-10-06T08:48:57CET","author":{"@id":"https://otter-framework.dev/#/schema/person/2"},"publisher":{"@id":"https://otter-framework.dev/#/schema/organization/1"},"image":{"@id":"https://otter-framework.dev/docs/case-study/engineering-challenges/#/schema/image/2"}}]},{"@context":"https://schema.org","@graph":[{"@type":"Person","@id":"https://otter-framework.dev/#/schema/person/2","name":"Henk Verlinde","sameAs":["https://twitter.com/henkverlinde","https://www.linkedin.com/in/henkverlinde/","https://github.com/h-enk"]}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://otter-framework.dev/docs/case-study/engineering-challenges/#/schema/image/2","url":"https://otter-framework.dev/doks.png","contentUrl":"https://otter-framework.dev/doks.png","caption":"Engineering Challenges"}]}]}</script><meta name=theme-color content="#fff"><link rel=icon href=https://otter-framework.dev/favicon.ico sizes=any><link rel=icon type=image/svg+xml href=https://otter-framework.dev/favicon.svg><link rel=apple-touch-icon sizes=180x180 href=https://otter-framework.dev/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://otter-framework.dev/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://otter-framework.dev/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://otter-framework.dev/site.webmanifest></head><body class="docs single"><div class=sticky-top><div class=header-bar></div><header class="navbar navbar-expand-lg navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0 mb-2" href=https://otter-framework.dev/ aria-label=Otter><img class=logo-light src=https://otter-framework.dev/images/otter-main-light.png width=90px>
<img class="logo-dark d-none" src=https://otter-framework.dev/images/otter-main.png width=90px></a>
<button class="btn btn-link order-0 ms-auto d-lg-none" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasExample aria-controls=offcanvasExample><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-more-horizontal"><circle cx="12" cy="12" r="1"/><circle cx="19" cy="12" r="1"/><circle cx="5" cy="12" r="1"/></svg></button><div class="offcanvas offcanvas-start d-lg-none" tabindex=-1 id=offcanvasExample aria-labelledby=offcanvasExampleLabel><div class=header-bar></div><div class=offcanvas-header><h5 class=offcanvas-title id=offcanvasExampleLabel>Browse docs</h5><button type=button class=btn-close data-bs-dismiss=offcanvas aria-label=Close></button></div><div class=offcanvas-body><aside class="doks-sidebar mt-n3"><nav id=doks-docs-nav aria-label="Tertiary navigation"><h3 class="h6 text-uppercase mb-2">Case Study</h3><ul class=list-unstyled><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/introduction/>Introduction</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/web-rtc/>How WebRTC Works</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/existing-solutions/>Existing Solutions</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/introducing-otter/>Introducing Otter</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/how-otter-is-built/>How Otter is Built</a></li><li><a class="docs-link active" href=https://otter-framework.dev/docs/case-study/engineering-challenges/>Engineering Challenges</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/future-work/>Future Work</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/references/>References</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/about-us/>About Us</a></li></ul><h3 class="h6 text-uppercase mb-2">Documentation</h3><ul class=list-unstyled><li><a class=docs-link href=https://otter-framework.dev/docs/documentations/quick-start/>Quick Start</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/documentations/commands/>Commands</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/documentations/how-to-update/>How to Update</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/documentations/troubleshooting/>Troubleshooting</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/documentations/otter-api/>Otter API</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/documentations/how-to-use-otter/>How to Use Otter</a></li></ul></nav></aside></div></div><button class="btn btn-menu order-2 d-block d-lg-none" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasDoks aria-controls=offcanvasDoks aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><div class="offcanvas offcanvas-end border-0 py-lg-1" tabindex=-1 id=offcanvasDoks data-bs-backdrop=true aria-labelledby=offcanvasDoksLabel><div class="header-bar d-lg-none"></div><div class="offcanvas-header d-lg-none"><h2 class="h5 offcanvas-title ps-2" id=offcanvasDoksLabel><a class=text-dark href=https://otter-framework.dev/>Otter</a></h2><button type=button class="btn-close text-reset me-2" data-bs-dismiss=offcanvas aria-label="Close main menu"></button></div><div class="offcanvas-body p-4 p-lg-0"><ul class="nav flex-column flex-lg-row align-items-lg-center mt-2 mt-lg-0 ms-lg-2 me-lg-auto"><li class=nav-item><a class="nav-link ps-0 py-1" href=https://otter-framework.dev/docs/case-study/introduction/>Case Study</a></li><li class=nav-item><a class="nav-link ps-0 py-1" href=https://otter-framework.dev/docs/documentations/>Documentations</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Get Started
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=https://otter-framework.dev/docs/case-study/quick-start/>Quick Start</a></li><li><a class=dropdown-item href=https://getdoks.org/tutorial/introduction/>Tutorial</a></li></ul></li></ul><hr class="text-black-50 my-4 d-lg-none"><form class="doks-search position-relative flex-grow-1 ms-lg-auto me-lg-2"><input id=search class="form-control is-search" type=search placeholder="Search docs..." aria-label="Search docs..." autocomplete=off><div id=suggestions class="shadow bg-white rounded d-none"></div></form><hr class="text-black-50 my-4 d-lg-none"><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=https://github.com/otter-framework><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><small class="ms-2 d-lg-none">GitHub</small></a></li></ul><hr class="text-black-50 my-4 d-lg-none"><button id=mode class="btn btn-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></div></div></nav></header></div><div class=container-xxl><aside class=doks-sidebar><nav id=doks-docs-nav class="collapse d-lg-none" aria-label="Tertiary navigation"><h3 class="h6 text-uppercase mb-2">Case Study</h3><ul class=list-unstyled><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/introduction/>Introduction</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/web-rtc/>How WebRTC Works</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/existing-solutions/>Existing Solutions</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/introducing-otter/>Introducing Otter</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/how-otter-is-built/>How Otter is Built</a></li><li><a class="docs-link active" href=https://otter-framework.dev/docs/case-study/engineering-challenges/>Engineering Challenges</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/future-work/>Future Work</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/references/>References</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/about-us/>About Us</a></li></ul><h3 class="h6 text-uppercase mb-2">Documentation</h3><ul class=list-unstyled><li><a class=docs-link href=https://otter-framework.dev/docs/documentations/quick-start/>Quick Start</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/documentations/commands/>Commands</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/documentations/how-to-update/>How to Update</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/documentations/troubleshooting/>Troubleshooting</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/documentations/otter-api/>Otter API</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/documentations/how-to-use-otter/>How to Use Otter</a></li></ul></nav></aside></div><div class="wrap container-xxl" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-4 col-xl-3 docs-sidebar d-none d-lg-block"><nav id=sidebar-default class=docs-links aria-label="Main navigation"><h3 class="h6 text-uppercase mb-2">Case Study</h3><ul class=list-unstyled><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/introduction/>Introduction</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/web-rtc/>How WebRTC Works</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/existing-solutions/>Existing Solutions</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/introducing-otter/>Introducing Otter</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/how-otter-is-built/>How Otter is Built</a></li><li><a class="docs-link active" href=https://otter-framework.dev/docs/case-study/engineering-challenges/>Engineering Challenges</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/future-work/>Future Work</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/references/>References</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/about-us/>About Us</a></li></ul><h3 class="h6 text-uppercase mb-2">Documentation</h3><ul class=list-unstyled><li><a class=docs-link href=https://otter-framework.dev/docs/documentations/quick-start/>Quick Start</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/documentations/commands/>Commands</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/documentations/how-to-update/>How to Update</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/documentations/troubleshooting/>Troubleshooting</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/documentations/otter-api/>Otter API</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/documentations/how-to-use-otter/>How to Use Otter</a></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=d-xl-none><button class="btn btn-outline-primary btn-sm doks-toc-toggle collapsed" type=button data-bs-toggle=collapse data-bs-target=#onThisPage aria-controls=doks-docs-nav aria-expanded=false aria-label="Toggle On this page navigation">
<span>On this page</span>
<span><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"/><polyline points="7 6 12 11 17 6"/></svg><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"/><polyline points="17 18 12 13 7 18"/></svg></span></button><div class=collapse id=onThisPage><div class="card card-body mt-3 py-1"><div class=page-links><nav id=TableOfContents><ul><li><a href=#webrtc-and-glare>WebRTC and Glare</a></li><li><a href=#signaling--dynamodb-optimization>Signaling & DynamoDB Optimization</a></li><li><a href=#static-site-generation--authentication>Static Site Generation & Authentication</a></li><li><a href=#coturn-session-state--sticky-session>CoTURN Session State & Sticky Session</a></li></ul></nav></div></div></div></div><div class="page-links d-none d-xl-block"><h3>On this page</h3><nav id=TableOfContents><ul><li><a href=#webrtc-and-glare>WebRTC and Glare</a></li><li><a href=#signaling--dynamodb-optimization>Signaling & DynamoDB Optimization</a></li><li><a href=#static-site-generation--authentication>Static Site Generation & Authentication</a></li><li><a href=#coturn-session-state--sticky-session>CoTURN Session State & Sticky Session</a></li></ul></nav></div></nav><main class="docs-content col-lg-12 col-xl-10"><h1>Engineering Challenges</h1><p class=lead></p><nav class=d-xl-none aria-label="Quaternary navigation"><div class=d-xl-none><button class="btn btn-outline-primary btn-sm doks-toc-toggle collapsed" type=button data-bs-toggle=collapse data-bs-target=#onThisPage aria-controls=doks-docs-nav aria-expanded=false aria-label="Toggle On this page navigation">
<span>On this page</span>
<span><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"/><polyline points="7 6 12 11 17 6"/></svg><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"/><polyline points="17 18 12 13 7 18"/></svg></span></button><div class=collapse id=onThisPage><div class="card card-body mt-3 py-1"><div class=page-links><nav id=TableOfContents><ul><li><a href=#webrtc-and-glare>WebRTC and Glare</a></li><li><a href=#signaling--dynamodb-optimization>Signaling & DynamoDB Optimization</a></li><li><a href=#static-site-generation--authentication>Static Site Generation & Authentication</a></li><li><a href=#coturn-session-state--sticky-session>CoTURN Session State & Sticky Session</a></li></ul></nav></div></div></div></div><div class="page-links d-none d-xl-block"><h3>On this page</h3><nav id=TableOfContents><ul><li><a href=#webrtc-and-glare>WebRTC and Glare</a></li><li><a href=#signaling--dynamodb-optimization>Signaling & DynamoDB Optimization</a></li><li><a href=#static-site-generation--authentication>Static Site Generation & Authentication</a></li><li><a href=#coturn-session-state--sticky-session>CoTURN Session State & Sticky Session</a></li></ul></nav></div></nav><p>The following is an in-depth discussion of 4 interesting engineering challenges we faced while building Otter.</p><h2 id=webrtc-and-glare>WebRTC and Glare <a href=#webrtc-and-glare class=anchor aria-hidden=true>#</a></h2><p>One challenge we faced working with the WebRTC API involved asynchronicity and race conditions. Ideally, the offer-answer process happens in an orderly fashion: one peer sends an offer, the other peer receives it and sends back an answer (if the other peer wishes to establish a P2P connection).</p><p>In practice, however, both peers can end up firing offers to each other in a haphazard fashion. This process is called negotiation, and it happens during the initial setup of the WebRTC session and anytime a change to the communication environment requires reconfiguring the session.</p><p>Such a change could happen when adding or removing media from a live WebRTC connection. Recall the Session Description object contains information about media types and codecs, so by adding or removing media, a peer’s Session Description has changed. Thus, a new offer needs to be generated and sent to the remote peer.</p><p>However, what happens if peers trigger such a change simultaneously? When both peers send offers to each other at the same time it disrupts their state machines and this is known as “glare”.</p><p>The default way of negotiating the offer-answer process in WebRTC introduces race conditions that cannot be resolved on their own, resulting in deadlock and errors. User intervention is required, which naturally translates into a poor user experience.</p><p>Instead, we need a way to handle glare in a resilient and programmatic manner. We need to isolate the negotiation process from the rest of the application. Enter Perfect Negotiation: a “<a href=https://w3c.github.io/webrtc-pc/#perfect-negotiation-example>recommended pattern to manage negotiation transparently, abstracting this asymmetric task away from the rest of the application</a>”. Perfect Negotiation works by assigning roles to either peer, where a peer’s role will specify the behavior to resolve any signaling collisions.</p><p>The two assigned roles are polite and impolite. A polite peer rescinds their offer in the face of an incoming offer, whereas an impolite peer ignores an incoming offer if it would collide with their own.</p><p>To implement Perfect Negotiation, we needed to add a couple of state variables to our peers: one to keep track if we are in the middle of an operation (recall the offer answer workflow is asynchronous), and another to indicate whether the peer is polite or impolite.</p><p>With Perfect Negotiation, we have resolved the race conditions that previously resulted in deadlock and poor user experience. Clients are able to add and remove media streams at will during a WebRTC session.</p><h2 id=signaling--dynamodb-optimization>Signaling & DynamoDB Optimization <a href=#signaling--dynamodb-optimization class=anchor aria-hidden=true>#</a></h2><p>Another challenge we faced was optimizing how signaling Lambdas interacted with DynamoDB. Let’s first understand how signaling Lambdas work with the WebSocket Gateway to send messages to a specific peer.</p><p>When a client establishes a connection with the WebSocket Gateway, the gateway creates a <span style=color:green>connectionId</span> to uniquely identify this connection. Whenever the gateway receives a message from the client, this <span style=color:green>connectionId</span> will be passed to the Lambda as a property of the <span style=color:green>context</span> object. To send a message to a client, the Lambda only needs to know the <span style=color:green>connectionId</span> of the client and make an API call to the gateway.</p><p>Recall that Otter has the concept of a “room” representing the virtual space where a session occurs. Every room has a <span style=color:green>roomId</span> property to uniquely identify it. Otter stores the <span style=color:green>connectionId</span> in the database with the <span style=color:green>roomId</span> to keep track of the room a peer resides in. With this simple schema in place, the signaling Lambda can now query the database with the <span style=color:green>roomId</span>, and pass the message if another peer is present. Initially, the message sent to the signaling Lambda had the following structure:</p><p>Since the signaling Lambda has access to the sender’s <span style=color:green>connectionId</span>, it can look up the <span style=color:green>roomId</span> in the database and determine the other peer’s <span style=color:green>connectionId</span> in order to pass the message to that peer. This approach is simple when sending and handling messages, however it also means the signaling Lambda will query DynamoDB for every message it receives.</p><p>Even without cold-starts, a signaling Lambda could take as long as ~1000ms when querying the database, which might be okay if we are only dealing with a few messages occasionally. However, under bursty traffic patterns, such slow performance could easily rack up compute time. Even worse, each peer connecting will send multiple candidate addresses asynchronously to the signaling Lambda. Each address triggers the Lambda to query the database for the same information.</p><p>In order to tackle this redundancy, the signaling Lambda should not have to determine the destination <span style=color:green>connectionId</span>. Instead, we reasoned both “source” and “destination” <span style=color:green>connectionId‘s</span> should be included in every message sent to the signaling Lambda. With the “destination” property, the signaling Lambda no longer needs to query the database to know where to send the message:</p><ol><li>If the “source” property is <span style=color:green>null</span>, the signaling Lambda can obtain the <span style=color:green>connectionId</span> from the WebSocket Gateway and fill in the blank.</li><li>If the “destination” property is <span style=color:green>null</span>, the signaling Lambda can query the database (only once) and fill the blank.</li><li>When the client receives a message from the other peer, it stores (or updates) both <span style=color:green>connectionIds</span> locally and includes them when sending all subsequent messages.</li></ol><p>Now the messages have the following structure:</p><p>When establishing the initial WebRTC connection, since the client doesn’t know any of the <span style=color:green>connectionIds</span>, the <span style=color:green>source</span> and <span style=color:green>destination</span> properties will be <span style=color:green>null</span>. As we mentioned earlier, these two properties will be filled by the signaling Lambda. This information is stored locally and used in all subsequent messages.</p><p>Given the scenario of a typical P2P session with no reconnection, we managed to reduce the number of database queries from ~20 to just one. This approach reduced the latency caused by Lambda execution from ~1000 ms to ~200ms.</p><h2 id=static-site-generation--authentication>Static Site Generation & Authentication <a href=#static-site-generation--authentication class=anchor aria-hidden=true>#</a></h2><p>Another challenge we encountered was how to build and deploy the Otter Web App. In order to join a video call, the Otter Web App has to first send two requests to the Otter API to verify the call is valid and to fetch the CoTURN credentials. Next, the Otter Web App must connect to the Websocket gateway to initiate signaling, and potentially contact the STUN/TURN infrastructure.</p><p>To interact with this infrastructure, the Otter Web App has to know the infrastructure’s endpoints, which means the Otter Web App cannot be built until said infrastructure has been provisioned. Thus, the Otter Web App could not be built in advance, and had to be built during <code>otter deploy</code>.</p><p>To make this happen, <code>otter deploy</code> spins up an EC2 instance, and uploads the endpoints for the infrastructure to an S3 bucket. The EC2 instance pulls the code for the Otter Web App from Github, and retrieves the endpoints from the S3 bucket. The EC2 instance then builds the Otter Web App using these endpoints, and publishes it to another S3 bucket, which is associated with Cloudfront. The S3 bucket with the endpoints and the EC2 instance is then terminated, and the website is hosted on Cloudfront.</p><p>However, this solution introduced another problem: the endpoints for the video calling infrastructure are exposed in the Javascript that is served to the end user. This highlighted the need to implement authentication within the infrastructure.</p><p>To secure our infrastructure, we decided to require the use of an API key. During <code>otter deploy</code>, an API key is generated, stored in a new table in DynamoDB, and displayed in the CLI. An authorizer Lambda is attached to both the HTTP API gateway and the Websocket gateway; this Lambda checks that the API key in an incoming request matches an API key stored in the database, and allows and denies traffic accordingly.</p><p>Given that Otter is a drop-in service for an application, we made an assumption that the developer using Otter will already have their own backend infrastructure. To create a video call, a developer would include this API key when making a request from their backend to the Otter API’s “createRoom” route.</p><p>However, another problem surfaces concerning the Otter Web App. When a user clicks on the link to join a video call, the Otter Web App needs to send multiple requests to the Otter API; these requests must include an API key. However, the Otter Web App is exposed to the end user.
How can the Otter Web App be authenticated, without exposing the API key to the end user?</p><p>To address this, we decided to implement JSON Web Tokens. A JSON Web Token (JWT) is a type of token used to securely transmit information (i.e. an API key) between parties.</p><p>When a request is sent to the Otter API’s “createRoom” route, the “createRoom” Lambda generates a JWT using the API key in the database and responds with a link to join the video call with the JWT in the query parameters.</p><p>When a user clicks on the link, the Otter Web App fetches the JWT from the query parameters of the URL and includes it in requests to the Otter infrastructure. The authorizer Lambda examines the JWT from the incoming request and verifies it using the API key stored in the database.</p><p>With this solution, accessing Otter’s infrastructure requires authorization, and the API key is not exposed to the end user.</p><h2 id=coturn-session-state--sticky-session>CoTURN Session State & Sticky Session <a href=#coturn-session-state--sticky-session class=anchor aria-hidden=true>#</a></h2><p>Deploying CoTURN to the cloud presented its own set of challenges. Two noteworthy ones were:</p><ul><li>The need for a CoTURN instance to automatically detect its assigned public IP address.</li><li>The need to track state across multiple CoTURN instances within the AWS ECS Cluster.</li></ul><p>Imagine peer A and peer B want to establish a direct peer-to-peer connection, where a TURN server is required for peer A. Both peers need to send their packets to CoTURN which would then relay them accordingly, but how do the peers determine what IP address to use?</p><p>When a new instance of CoTURN is launched within the cluster, we execute a script that relies on the Domain Name System (DNS) protocol to figure out the public IP address assigned to the container. Well-established providers such as OpenDNS or Google offer special hostnames that, when resolved, will return the IP address of the caller. This could also have been done by sending an HTTP request to specific providers that offer the public IP address in their response body. However, HTTP has more overhead, and parsing the response is more time-consuming than using DNS.</p><p>Now that CoTURN is aware of its IP address, Peer A asks CoTURN if it is able to relay packets to peer B. If successful, CoTURN allocates a session for peer A. This session indicates that CoTURN is stateful and consists primarily of the following: a public IP address which represents the IP address of CoTURN; a randomly chosen port for peer B to use to relay its packets to peer A; and a permission which indicates that only packets from peer B should be relayed back to peer A and all other packets should be discarded. The permission is primarily a security feature.</p><p>Once the session is allocated, peer A can send CoTURN’s IP address and chosen port to peer B through the signaling channel as usual.</p><p>To make sure that CoTURN has access to the client’s state when handling requests, we opted for sticky sessions applied by the network load balancer. The network load balancer assigns each client a CoTURN instance from the cluster for the duration of the connection. This was a straightforward approach and did not require any changes to our application. However, if an instance fails all associated client state is lost. Furthermore, sticky sessions can impede the ability of the network load balancer to distribute the incoming traffic evenly due to client state being present in the individual instances.</p><p>Another option could have been to use a key-value store to hold all session allocation states. In this case, all CoTURN instances need to have access to this store to retrieve the client’s state on each request. The individual CoTURN instances become stateless and there is no need for the network load balancer to apply sticky sessions anymore. However, the complexity of extracting the state from the instances and the increased latency to retrieve a particular client state from the store were significant enough to outweigh the benefits of this approach, especially compared to the simplicity of the sticky session approach</p><div class="page-footer-meta d-flex flex-column flex-md-row justify-content-between"></div><div class="docs-navigation d-flex justify-content-between"><a href=https://otter-framework.dev/docs/case-study/how-otter-is-built/><div class="card my-1"><div class="card-body py-2">&larr; How Otter is Built</div></div></a><a class=ms-auto href=https://otter-framework.dev/docs/case-study/future-work/><div class="card my-1"><div class="card-body py-2">Future Work &rarr;</div></div></a></div></main></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Powered by <a class=text-muted href=https://www.netlify.com/>Netlify</a>, <a class=text-muted href=https://gohugo.io/>Hugo</a>, and <a class=text-muted href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline></ul></div></div></div></footer><script src=https://otter-framework.dev/js/bootstrap.min.87685cf4e6585276ff9e7b5d0b97e792615af6921e77821315d1ca7c5511ac2f30667e16c0d031e680ca8b57f63f6c0f6c4a232da777cce474b501ed81e090a9.js integrity="sha512-h2hc9OZYUnb/nntdC5fnkmFa9pIed4ITFdHKfFURrC8wZn4WwNAx5oDKi1f2P2wPbEojLad3zOR0tQHtgeCQqQ==" crossorigin=anonymous defer></script>
<script src=https://otter-framework.dev/js/highlight.min.56a414730f1135fe77b5ea30bf74a2cc4101a6f386e85e5b789c800570cc33d33054000f45932c053a59b41018f72687867254a80e1b9710671852492533162f.js integrity="sha512-VqQUcw8RNf53teowv3SizEEBpvOG6F5beJyABXDMM9MwVAAPRZMsBTpZtBAY9yaHhnJUqA4blxBnGFJJJTMWLw==" crossorigin=anonymous defer></script>
<script src=https://otter-framework.dev/main.min.48112dadd832db3af6d4d33366c964d3fbb9a6650b84f6a6bc5e79c3ba86d94a2e7fe3515d588ad342a14de3260a6ffd2f49830115f6213a7e3b563ff9de1801.js integrity="sha512-SBEtrdgy2zr21NMzZslk0/u5pmULhPamvF55w7qG2Uouf+NRXViK00KhTeMmCm/9L0mDARX2ITp+O1Y/+d4YAQ==" crossorigin=anonymous defer></script>
<script src=https://otter-framework.dev/index.min.794cea15a151943ac139a010f8e8f1346df09d06426abde8e0f91d9259af5efc841496ae66978203bff6472fa0b0bb98ada11d68948b52f8c431d7b813a9c78a.js integrity="sha512-eUzqFaFRlDrBOaAQ+OjxNG3wnQZCar3o4PkdklmvXvyEFJauZpeCA7/2Ry+gsLuYraEdaJSLUvjEMde4E6nHig==" crossorigin=anonymous defer></script><div class="d-flex fixed-bottom pb-4 pb-lg-5 pe-4 pe-lg-5"><a id=toTop href=# class="btn btn-outline-primary rounded-circle ms-auto p-2"><span class=visually-hidden>Top</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-up"><polyline points="18 15 12 9 6 15"/></svg></a></div></body></html>