<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=stylesheet type=text/css href=asciinema-player.css><link rel=preload as=font href=https://otter-framework.dev/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://otter-framework.dev/fonts/vendor/jost/jost-v4-latin-500.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://otter-framework.dev/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><link rel=stylesheet href=https://otter-framework.dev/main.1ceb5f88fb530d1461e4698b552b7a51a501d32f8035086019853dfa4fd27db3127d1d9e22723bb66a97841e85b8eacb1b23763bbf9f3322bd3b001aaf8f4d87.css integrity="sha512-HOtfiPtTDRRh5GmLVSt6UaUB0y+ANQhgGYU9+k/SfbMSfR2eInI7tmqXhB6FuOrLGyN2O7+fMyK9OwAar49Nhw==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>How Otter is Built - Otter</title><meta name=description content="Architecture Overview #Next, we will explore the design decisions of how we built Otter. We split this exploration into three overall design objectives:
Provisioning the infrastructure to support video calling. Abstracting away the complexity of interacting with this video calling infrastructure. Allowing developers to integrate Otter into their applications. We segmented the architecture into logical groupings of components that together fulfill these objectives as they interact. We will refer to these groupings as stacks."><link rel=canonical href=https://otter-framework.dev/docs/case-study/how-otter-is-built/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="How Otter is Built"><meta property="og:description" content="Architecture Overview #Next, we will explore the design decisions of how we built Otter. We split this exploration into three overall design objectives:
Provisioning the infrastructure to support video calling. Abstracting away the complexity of interacting with this video calling infrastructure. Allowing developers to integrate Otter into their applications. We segmented the architecture into logical groupings of components that together fulfill these objectives as they interact. We will refer to these groupings as stacks."><meta property="og:url" content="https://otter-framework.dev/docs/case-study/how-otter-is-built/"><meta property="og:site_name" content="Otter"><meta property="article:published_time" content="2020-10-06T08:48:57+00:00"><meta property="article:modified_time" content="2020-10-06T08:48:57+00:00"><meta property="og:image" content="https://otter-framework.dev/doks.png"><meta property="og:image:alt" content="Otter"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content="@getdoks"><meta name=twitter:creator content="@henkverlinde"><meta name=twitter:title content="How Otter is Built"><meta name=twitter:description content><meta name=twitter:image content="https://otter-framework.dev/doks.png"><meta name=twitter:image:alt content="How Otter is Built"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://otter-framework.dev/#/schema/organization/1","name":"Doks","url":"https://otter-framework.dev/","sameAs":["https://twitter.com/getdoks","https://github.com/h-enk/doks"],"logo":{"@type":"ImageObject","@id":"https://otter-framework.dev/#/schema/image/1","url":"https://otter-framework.dev/logo-doks.png","width":512,"height":512,"caption":"Doks"},"image":{"@id":"https://otter-framework.dev/#/schema/image/1"}},{"@type":"WebSite","@id":"https://otter-framework.dev/#/schema/website/1","url":"https://otter-framework.dev/","name":"Otter","description":"Otter is a drop-in solution that facilitates peer-to-peer video communication within web applications.","publisher":{"@id":"https://otter-framework.dev/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://otter-framework.dev/docs/case-study/how-otter-is-built/","url":"https://otter-framework.dev/docs/case-study/how-otter-is-built/","name":"How Otter is Built","description":"","isPartOf":{"@id":"https://otter-framework.dev/#/schema/website/1"},"about":{"@id":"https://otter-framework.dev/#/schema/organization/1"},"datePublished":"2020-10-06T08:48:57CET","dateModified":"2020-10-06T08:48:57CET","breadcrumb":{"@id":"https://otter-framework.dev/docs/case-study/how-otter-is-built/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://otter-framework.dev/docs/case-study/how-otter-is-built/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://otter-framework.dev/docs/case-study/how-otter-is-built/"]}]},{"@type":"BreadcrumbList","@id":"https://otter-framework.dev/docs/case-study/how-otter-is-built/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://otter-framework.dev/","url":"https://otter-framework.dev/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://otter-framework.dev/docs/","url":"https://otter-framework.dev/docs/","name":"Docs"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://otter-framework.dev/docs/case-study/","url":"https://otter-framework.dev/docs/case-study/","name":"Case Study"}},{"@type":"ListItem","position":4,"item":{"@id":"https://otter-framework.dev/docs/case-study/how-otter-is-built/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"Article","@id":"https://otter-framework.dev/#/schema/article/1","headline":"How Otter is Built","description":"","isPartOf":{"@id":"https://otter-framework.dev/docs/case-study/how-otter-is-built/"},"mainEntityOfPage":{"@id":"https://otter-framework.dev/docs/case-study/how-otter-is-built/"},"datePublished":"2020-10-06T08:48:57CET","dateModified":"2020-10-06T08:48:57CET","author":{"@id":"https://otter-framework.dev/#/schema/person/2"},"publisher":{"@id":"https://otter-framework.dev/#/schema/organization/1"},"image":{"@id":"https://otter-framework.dev/docs/case-study/how-otter-is-built/#/schema/image/2"}}]},{"@context":"https://schema.org","@graph":[{"@type":"Person","@id":"https://otter-framework.dev/#/schema/person/2","name":"Henk Verlinde","sameAs":["https://twitter.com/henkverlinde","https://www.linkedin.com/in/henkverlinde/","https://github.com/h-enk"]}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://otter-framework.dev/docs/case-study/how-otter-is-built/#/schema/image/2","url":"https://otter-framework.dev/doks.png","contentUrl":"https://otter-framework.dev/doks.png","caption":"How Otter is Built"}]}]}</script><meta name=theme-color content="#fff"><link rel=icon href=https://otter-framework.dev/favicon.ico sizes=any><link rel=icon type=image/svg+xml href=https://otter-framework.dev/favicon.svg><link rel=apple-touch-icon sizes=180x180 href=https://otter-framework.dev/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://otter-framework.dev/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://otter-framework.dev/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://otter-framework.dev/site.webmanifest></head><body class="docs single"><div class=sticky-top><div class=header-bar></div><header class="navbar navbar-expand-lg navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0 mb-2" href=https://otter-framework.dev/ aria-label=Otter><img class=logo-light src=https://otter-framework.dev/images/otter-main-light.png width=90px>
<img class="logo-dark d-none" src=https://otter-framework.dev/images/otter-main.png width=90px></a>
<button class="btn btn-link order-0 ms-auto d-lg-none" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasExample aria-controls=offcanvasExample><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-more-horizontal"><circle cx="12" cy="12" r="1"/><circle cx="19" cy="12" r="1"/><circle cx="5" cy="12" r="1"/></svg></button><div class="offcanvas offcanvas-start d-lg-none" tabindex=-1 id=offcanvasExample aria-labelledby=offcanvasExampleLabel><div class=header-bar></div><div class=offcanvas-header><h5 class=offcanvas-title id=offcanvasExampleLabel>Browse docs</h5><button type=button class=btn-close data-bs-dismiss=offcanvas aria-label=Close></button></div><div class=offcanvas-body><aside class="doks-sidebar mt-n3"><nav id=doks-docs-nav aria-label="Tertiary navigation"><h3 class="h6 text-uppercase mb-2">Case Study</h3><ul class=list-unstyled><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/introduction/>Introduction</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/web-rtc/>How WebRTC Works</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/existing-solutions/>Existing Solutions</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/introducing-otter/>Introducing Otter</a></li><li><a class="docs-link active" href=https://otter-framework.dev/docs/case-study/how-otter-is-built/>How Otter is Built</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/engineering-challenges/>Engineering Challenges</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/future-work/>Future Work</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/references/>References</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/about-us/>About Us</a></li></ul><h3 class="h6 text-uppercase mb-2">Documentation</h3><ul class=list-unstyled><li><a class=docs-link href=https://otter-framework.dev/docs/documentations/quick-start/>Quick Start</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/documentations/commands/>Commands</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/documentations/how-to-update/>How to Update</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/documentations/troubleshooting/>Troubleshooting</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/documentations/otter-api/>Otter API</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/documentations/how-to-use-otter/>How to Use Otter</a></li></ul></nav></aside></div></div><button class="btn btn-menu order-2 d-block d-lg-none" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasDoks aria-controls=offcanvasDoks aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><div class="offcanvas offcanvas-end border-0 py-lg-1" tabindex=-1 id=offcanvasDoks data-bs-backdrop=true aria-labelledby=offcanvasDoksLabel><div class="header-bar d-lg-none"></div><div class="offcanvas-header d-lg-none"><h2 class="h5 offcanvas-title ps-2" id=offcanvasDoksLabel><a class=text-dark href=https://otter-framework.dev/>Otter</a></h2><button type=button class="btn-close text-reset me-2" data-bs-dismiss=offcanvas aria-label="Close main menu"></button></div><div class="offcanvas-body p-4 p-lg-0"><ul class="nav flex-column flex-lg-row align-items-lg-center mt-2 mt-lg-0 ms-lg-2 me-lg-auto"><li class=nav-item><a class="nav-link ps-0 py-1" href=https://otter-framework.dev/docs/case-study/introduction/>Case Study</a></li><li class=nav-item><a class="nav-link ps-0 py-1" href=https://otter-framework.dev/docs/documentations/>Documentations</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Get Started
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=https://otter-framework.dev/docs/case-study/quick-start/>Quick Start</a></li><li><a class=dropdown-item href=https://getdoks.org/tutorial/introduction/>Tutorial</a></li></ul></li></ul><hr class="text-black-50 my-4 d-lg-none"><form class="doks-search position-relative flex-grow-1 ms-lg-auto me-lg-2"><input id=search class="form-control is-search" type=search placeholder="Search docs..." aria-label="Search docs..." autocomplete=off><div id=suggestions class="shadow bg-white rounded d-none"></div></form><hr class="text-black-50 my-4 d-lg-none"><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=https://github.com/otter-framework><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><small class="ms-2 d-lg-none">GitHub</small></a></li></ul><hr class="text-black-50 my-4 d-lg-none"><button id=mode class="btn btn-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></div></div></nav></header></div><div class=container-xxl><aside class=doks-sidebar><nav id=doks-docs-nav class="collapse d-lg-none" aria-label="Tertiary navigation"><h3 class="h6 text-uppercase mb-2">Case Study</h3><ul class=list-unstyled><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/introduction/>Introduction</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/web-rtc/>How WebRTC Works</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/existing-solutions/>Existing Solutions</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/introducing-otter/>Introducing Otter</a></li><li><a class="docs-link active" href=https://otter-framework.dev/docs/case-study/how-otter-is-built/>How Otter is Built</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/engineering-challenges/>Engineering Challenges</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/future-work/>Future Work</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/references/>References</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/about-us/>About Us</a></li></ul><h3 class="h6 text-uppercase mb-2">Documentation</h3><ul class=list-unstyled><li><a class=docs-link href=https://otter-framework.dev/docs/documentations/quick-start/>Quick Start</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/documentations/commands/>Commands</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/documentations/how-to-update/>How to Update</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/documentations/troubleshooting/>Troubleshooting</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/documentations/otter-api/>Otter API</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/documentations/how-to-use-otter/>How to Use Otter</a></li></ul></nav></aside></div><div class="wrap container-xxl" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-4 col-xl-3 docs-sidebar d-none d-lg-block"><nav id=sidebar-default class=docs-links aria-label="Main navigation"><h3 class="h6 text-uppercase mb-2">Case Study</h3><ul class=list-unstyled><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/introduction/>Introduction</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/web-rtc/>How WebRTC Works</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/existing-solutions/>Existing Solutions</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/introducing-otter/>Introducing Otter</a></li><li><a class="docs-link active" href=https://otter-framework.dev/docs/case-study/how-otter-is-built/>How Otter is Built</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/engineering-challenges/>Engineering Challenges</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/future-work/>Future Work</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/references/>References</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/case-study/about-us/>About Us</a></li></ul><h3 class="h6 text-uppercase mb-2">Documentation</h3><ul class=list-unstyled><li><a class=docs-link href=https://otter-framework.dev/docs/documentations/quick-start/>Quick Start</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/documentations/commands/>Commands</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/documentations/how-to-update/>How to Update</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/documentations/troubleshooting/>Troubleshooting</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/documentations/otter-api/>Otter API</a></li><li><a class=docs-link href=https://otter-framework.dev/docs/documentations/how-to-use-otter/>How to Use Otter</a></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=d-xl-none><button class="btn btn-outline-primary btn-sm doks-toc-toggle collapsed" type=button data-bs-toggle=collapse data-bs-target=#onThisPage aria-controls=doks-docs-nav aria-expanded=false aria-label="Toggle On this page navigation">
<span>On this page</span>
<span><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"/><polyline points="7 6 12 11 17 6"/></svg><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"/><polyline points="17 18 12 13 7 18"/></svg></span></button><div class=collapse id=onThisPage><div class="card card-body mt-3 py-1"><div class=page-links><nav id=TableOfContents><ul><li><a href=#architecture-overview>Architecture Overview</a><ul><li></li></ul></li><li><a href=#notes>Notes</a></li></ul></nav></div></div></div></div><div class="page-links d-none d-xl-block"><h3>On this page</h3><nav id=TableOfContents><ul><li><a href=#architecture-overview>Architecture Overview</a><ul><li></li></ul></li><li><a href=#notes>Notes</a></li></ul></nav></div></nav><main class="docs-content col-lg-12 col-xl-10"><h1>How Otter is Built</h1><p class=lead></p><nav class=d-xl-none aria-label="Quaternary navigation"><div class=d-xl-none><button class="btn btn-outline-primary btn-sm doks-toc-toggle collapsed" type=button data-bs-toggle=collapse data-bs-target=#onThisPage aria-controls=doks-docs-nav aria-expanded=false aria-label="Toggle On this page navigation">
<span>On this page</span>
<span><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"/><polyline points="7 6 12 11 17 6"/></svg><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"/><polyline points="17 18 12 13 7 18"/></svg></span></button><div class=collapse id=onThisPage><div class="card card-body mt-3 py-1"><div class=page-links><nav id=TableOfContents><ul><li><a href=#architecture-overview>Architecture Overview</a><ul><li></li></ul></li><li><a href=#notes>Notes</a></li></ul></nav></div></div></div></div><div class="page-links d-none d-xl-block"><h3>On this page</h3><nav id=TableOfContents><ul><li><a href=#architecture-overview>Architecture Overview</a><ul><li></li></ul></li><li><a href=#notes>Notes</a></li></ul></nav></div></nav><h2 id=architecture-overview>Architecture Overview <a href=#architecture-overview class=anchor aria-hidden=true>#</a></h2><p>Next, we will explore the design decisions of how we built Otter. We split this exploration into three overall design objectives:</p><ol><li>Provisioning the infrastructure to support video calling.</li><li>Abstracting away the complexity of interacting with this video calling infrastructure.</li><li>Allowing developers to integrate Otter into their applications.</li></ol><p>We segmented the architecture into logical groupings of components that together fulfill these objectives as they interact. We will refer to these groupings as stacks. The four stacks we will discuss are the Signaling stack, the STUN/TURN stack, the Frontend stack and the API stack.</p><p>Recall the components we needed for video calling in a P2P manner: a signaling server, a STUN server and a TURN server. The signaling server provides a way for peers to exchange Session Description information, including information provided by the STUN and TURN servers. The Signaling stack and STUN/TURN stack fulfill the first objective: to provide the infrastructure to support video calling.</p><p>However, without a way to interact with this infrastructure, a developer would still need to have an understanding of the WebRTC API to develop, test and deploy a video calling application.</p><p>The Frontend stack abstracts this complexity away from the developer by providing a video calling application which interacts with the Otter infrastructure. We will refer to this video calling application as the Otter Web App. Built with the WebRTC API and by consuming resources provided by the API stack, the Otter Web App offers audio/video calling, instant messaging, and file sharing between two peers. In addition, the Frontend stack manages hosting the Otter Web App.</p><p>To be considered a drop-in framework, developers need an easy way to integrate Otter into their applications. The API stack provides a route that dynamically generates a link to the Otter Web App for this purpose.</p><p>Let’s now peer into each stack.</p><h4 id=the-signaling-stack>The Signaling Stack <a href=#the-signaling-stack class=anchor aria-hidden=true>#</a></h4><p>The purpose of the signaling server in the context of WebRTC is to serve as a mechanism to transfer messages between peers. Recall, signaling is not defined in the RFC and instead left to the developer to implement.</p><p>We needed our signaling server to have the following qualities:</p><ul><li>Low-latency for a real-time<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> application (sub 100ms).</li><li>Asynchronous, two-way communication between client and server.</li><li>Scale to handle connections as needed.</li></ul><p>An option we considered was XHR polling, where a client periodically makes requests to the server asking for new data. However, polling “<a href=https://www.rfc-editor.org/rfc/rfc6202#section-2.2>stretch[es] the original semantics of HTTP and that HTTP was not designed for bidirectional communication</a>”.</p><p>Instead, the WebSocket protocol was a natural fit given our requirements. The protocol offers bidirectional communication (where the client and server can exchange data asynchronously), low latency (once a connection is established), and no limits on the number of concurrent connections.</p><h5 id=implementing-websocket-communication-channels>Implementing WebSocket Communication Channels <a href=#implementing-websocket-communication-channels class=anchor aria-hidden=true>#</a></h5><p>A typical WebSocket server will have the following:</p><ul><li>Event listener for connecting clients and assigning an identifier to each client.</li><li>Event listener for sending messages between clients, using the identifier of each client.</li><li>Event listener for disconnecting clients and deleting the identifier for each client.</li></ul><p>Recall the nature of a WebRTC session is that media flows directly from browser to browser. This means once clients (peers) connect to the WebSocket server and pass their initial messages (offers and answers) to their peers to establish the WebRTC session, the WebSocket server typically remains idle. Peers must maintain long-lived connections to the server in the case of subsequent negotiations.</p><p>This traffic pattern implies bursts of requests to the WebSocket server on the initial set up of a WebRTC session, and intermittent or irregular requests thereafter. Thus, it would be appropriate for our WebSocket server to be able to handle bursty and irregular traffic on demand.</p><p>AWS API WebSocket Gateway was a perfect fit for these requirements and traffic patterns. The gateway would serve as a single endpoint for all clients and it would rely on event listeners to fulfill the functions of connecting clients and assigning identifiers, sending messages between clients using their identifiers, and disconnecting clients and removing their identifiers.</p><p>To serve the role of event listeners behind the gateway, we needed a service that would be on demand or event based, easy to manage and auto-scalable. AWS Lambdas were just the fit. Lambdas are a service provided by AWS that offer Functions-as-a-Service. Lambdas are considered serverless since a developer only needs to focus on core application logic, and need not provision nor manage servers that the code would otherwise need to run on. Another option would have been running a server on a EC2 instance, but the Lambdas made more sense given our event based traffic patterns and our approach towards low maintenance infrastructure.</p><p>We mapped each event listener to a separate Lambda: one for connecting clients and assigning identifiers; one for passing messages between connected clients; and another for disconnecting clients and removing their identifiers.</p><p>We were also able to use a Lambda to authorize access to the gateway, which will be discussed later in the Engineering Challenges.</p><p>We can see a natural separation of responsibilities between the WebSocket gateway and the Lambdas. The WebSocket gateway maintains long-lived connections with the clients, whereas the Lambdas are event based and are not regularly invoked after an initial WebRTC session is established. This lends well to their on demand nature.</p><p>Choosing the API WebSocket gateway came with two tradeoffs:</p><ul><li>The gateway is stateless and needs to persist the identifiers assigned to each connected client.</li><li>The gateway cannot broadcast or send messages to multiple client connections with a single API call.</li></ul><p>We were able to mitigate the first tradeoff by employing a database to persist the identifier assigned to each client as a key-value pair in a NoSQL database (DynamoDB) lookup table. The second tradeoff was a non-issue with a P2P topology: there was no need to broadcast messages to more than a few client connections (peers).</p><p>Choosing Lambdas came with two tradeoffs:</p><ul><li><strong>Cold starts</strong>: latency when a Lambda is first spun up.</li><li><strong>Limited execution time</strong>: a Lambda will be torn down after 15 minutes.</li></ul><p>These tradeoffs were acceptable considering the overall latency of setting up a WebRTC session was longer than that of the cold start and that each of our function calls to the Lambda were not computationally longer than a second.</p><h4 id=the-stunturn-stack>The STUN/TURN Stack <a href=#the-stunturn-stack class=anchor aria-hidden=true>#</a></h4><p>As we have previously discussed, establishing a direct peer-to-peer connection requires traversing multiple layers of NAT devices. Thus, a STUN server is required to allow both peers to acquire their public IP address. Furthermore, a direct connection between peers may not be possible under restrictive network configurations. Thus, a TURN server is required to relay the media for the session when needed.</p><p>To deploy a STUN/TURN server, we first needed to decide whether an open-source, a free third-party, or a DIY implementation would fit best within Otter.</p><p>Amongst the open-source options is CoTURN. CoTURN provides the functionality required for both STUN and TURN. Having a single component providing both functionalities would reduce the complexity of our infrastructure and its deployment. It is also the most widely used TURN server, open-source or otherwise, and has an active development community.</p><p>On the other hand, deploying CoTURN requires non-trivial configuration and the available documentation is limited. Moreover, deploying both STUN and TURN functionality within the same component does remove a degree of freedom, as it is no longer possible to scale one without the other. Considering these benefits and drawbacks, we decided to use CoTURN as it seemed like a natural fit for our application.</p><p>Interestingly, there are also publicly available STUN and TURN servers that are free to use. These servers are hosted by third-party providers such as Google. We decided against this option for two reasons: the inherent uncertainty around free services and whether or not they will continue to be free or available; and using a third-party TURN server defeats the purpose of a self-contained infrastructure in the context of privacy.</p><p>Lastly, we could have implemented a DIY STUN/TURN server, but given the time and complexity associated with this, we decided to focus on the core application functionality.</p><h5 id=deploying-coturn>Deploying CoTURN <a href=#deploying-coturn class=anchor aria-hidden=true>#</a></h5><p>We listed the following requirements as must-haves for the deployment of CoTURN:</p><ul><li>Low maintenance.</li><li>A public IP address.</li><li>Ability to scale depending on the traffic load.</li></ul><p>With this in mind, we knew that CoTURN needed to be deployed in a serverless fashion to eliminate the maintenance associated with the underlying operating system. Additionally, it needed to be deployed within a public subnet to be able to relay media between peers. It also needed to be able to handle heavier traffic loads, otherwise it could become a bottleneck in the infrastructure if all other stacks auto-scaled and CoTURN did not.</p><p>Deploying CoTURN without having to manage the underlying server required a platform where software could run within a container. AWS Fargate is a service that developers can use to run containers without having to provision, configure, and maintain servers. This allows the developer to focus on the application’s core business logic. With AWS Fargate, we would be able to run CoTURN in a container with a public IP address within a public subnet.</p><p>To address scalability, we first needed to determine how many concurrent P2P sessions one instance of a CoTURN container could support. We considered the CPU and RAM available to an instance of a CoTURN container, and estimated that such an instance could handle up to 25 concurrent<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> media relaying sessions. However, not all sessions require a TURN server; recall only 8% of P2P connections do, while the other 92% can be handled by a STUN server.</p><p>If 25 concurrent sessions represents 8% of P2P calls, then one instance can support around 310 total P2P concurrent sessions.</p><p>Therefore, an ideal scenario for auto-scaling would be to have at least one instance running at all times and to scale depending on the number of concurrent P2P sessions. Luckily, AWS Elastic Container Service (ECS) does just that.</p><p>AWS ECS is a fully managed container orchestration service. Otter’s STUN/TURN stack is an ECS Cluster of CoTURN containers. A service is configured to always maintain at least one instance within the cluster and to increase or decrease the number of instances depending on a target CPU utilization (i.e. 75%) within the cluster.</p><p>Given that the cluster may have multiple instances of CoTURN running, a new component was needed to direct incoming traffic within the cluster. We used a network load balancer to fulfill this task. Clients are only aware of the network load balancer endpoint. The ECS Service can scale as needed.</p><p>The above infrastructure has its merits, but it also has the following drawbacks:</p><ul><li>There is a steep learning curve to get started with ECS as there are many different concepts involved (i.e. task definition, cluster, service discovery, health checks, etc).</li><li>Fargate is generally more costly and less flexible than running the equivalent software on an EC2 instance.</li><li>Monitoring and observability remain challenging with Fargate as containerized code is not easily accessible.</li></ul><p>Given the above downsides were not significant impediments to our application, it made sense to use ECS with Fargate for CoTURN.</p><p>The other competitive option to using Fargate would have been to deploy CoTURN on an EC2 instance. However, that would have involved maintenance of the virtual machine, something that Otter aims to avoid.</p><h4 id=the-frontend-stack>The Frontend Stack <a href=#the-frontend-stack class=anchor aria-hidden=true>#</a></h4><p>By this point, we have fulfilled the objective of setting up infrastructure to facilitate video calling. However, to use this infrastructure to host video calls, a developer would still have to interact with the WebRTC API to design, test and deploy their own frontend video calling application. In addition, a developer would need to host this frontend video calling application.</p><p>The purpose of the Frontend stack is to abstract away this complexity by providing and hosting the Otter Web App. The Otter Web App consumes two resources from the API stack (next stack discussed) that allow it to connect and plug into the infrastructure provided by the Signaling stack and STUN/TURN stack. The Otter Web App interacts with WebRTC API to handle offers, answers and set up connections between peers. Using these connections, peers can process video streams, share files and instant messages. When a user attempts to visit a link (generated using the API stack), the user will be served the Otter Web App, which will automatically join the video call associated with the given link (similar to how Google Meet works).</p><p>The hosting of the Otter Web App is accomplished using AWS Cloudfront (a Content Delivery Network), which distributes a website hosted in an AWS S3 bucket. While we considered a web server, we chose Cloudfront and S3 for several reasons. A web server seemed like overkill since the same static website is served for each request. Additionally, Cloudfront distributes content from edge locations that are closest to the end user, which can reduce the latency that the user experiences when loading the site.</p><p>The building of the Otter Web App was accomplished using an EC2 instance, but this presented a new set of challenges which will be discussed later.</p><h4 id=the-api-stack>The API Stack <a href=#the-api-stack class=anchor aria-hidden=true>#</a></h4><p>The API stack serves two purposes. First, it provides an easy way for developers to integrate Otter into their applications. This is achieved through a single route, namely <strong>/createRoom</strong>. Second, as we alluded to in the Frontend stack, it exposes resources that are consumed by the Otter Web App. This is achieved through two routes, namely <strong>/room/{id}</strong> and <strong>/credentials</strong>.</p><p>The <strong>/createRoom</strong> route allows a developer to issue an HTTP POST request in order to create a uniquely identifiable room resource. The room resource represents a virtual P2P session that will be hosted on the Otter Web App. The route performs the following tasks when triggered:</p><ul><li>Creates the room resource and stores relevant meta-data into DynamoDB.</li><li>Generates a unique URL that points to a Cloudfront Distribution where the Otter Web App is hosted.</li><li>Appends the URL to the response body which is sent back to the developer.</li></ul><p>It is important to understand that this URL is bound to the room resource it was generated for. In other words, consuming the <strong>/createRoom</strong> endpoint is the only way to have a virtual P2P session hosted on the Otter Web App. A developer who uses Otter should only have to think about how to integrate this route into his own web application. Everything else is self-contained within Otter.</p><p>The two additional routes that the API stack provides, <strong>/room/{id}</strong> and <strong>/credentials</strong>, are consumed by the Otter Web App. The <strong>/room/{id}</strong> route fetches the meta-data of the associated room resource whereas the <strong>/credentials</strong> route fetches the time-limited credentials to access the functionality provided by the STUN/TURN stack. Once loaded, the Otter Web App issues a request to both routes in order to gather all the information required to start the virtual P2P session.</p><p>In short, the life cycle of a P2P session includes the following 5 API calls:</p><ul><li>One API call (<strong>/createRoom</strong> issued by an end user) to create the room resource.</li><li>Two API calls (<strong>/room/{id}</strong> issued by the Otter Web App for each peer) to fetch the room’s metadata.</li><li>Two API calls (<strong>/credentials</strong> issued by the Otter Web App for each peer) to fetch the STUN/TURN stack credentials.</li></ul><p>Once the virtual P2P session has begun, all further traffic either flows directly between the peers or through the Signaling stack. It therefore did not make sense to have a server running at all times to handle these API calls. For every new virtual P2P session, the <strong>/room/{id}</strong> and <strong>/credentials</strong> routes will receive twice as much traffic as the <strong>/createRoom</strong> route therefore indicating a different computing need. Identifying these different needs allowed us to deploy an infrastructure that provides on-demand execution.</p><p>AWS Lambda not only provided us with this on-demand execution but also with minimal maintenance. This characteristic aligns with the drop-in nature of the Otter framework. Furthermore, AWS Lambda functions are also able to handle heavier traffic without any manual intervention. Since each session requires 5 API calls, this auto-scaling feature could become valuable when many virtual P2P sessions are initiated within a short period of time.</p><p>The API stack is thus composed of three distinct AWS Lambda functions, one for each route described above. The functions are connected to a DynamoDB database where the room resources are persisted. Furthermore, to have a single point of contact for these three different routes and to properly manage the communication between the client and the AWS Lambda functions, we deployed an AWS HTTP API Gateway in front of the functions. Therefore, all API calls are sent to the HTTP API Gateway which takes care of routing them to the appropriate handler.</p><p>Finally, we also have a Lambda Authorizer function attached to the gateway to control the access to the resources. We will explore the implementation of this authorizer within the Engineering Challenges section.</p><h4 id=architecture-summary>Architecture Summary <a href=#architecture-summary class=anchor aria-hidden=true>#</a></h4><p>In summary, we segmented our architecture into stacks (the Signaling stack, the STUN/TURN stack, the Frontend Stack, the API stack) that together fulfill three objectives:</p><ol><li>Provisioning the infrastructure to support video calling.</li><li>Abstracting away the complexity of interacting with this video calling infrastructure.</li><li>Allowing developers to integrate Otter into their applications.</li></ol><p>The system altogether looks like the following:</p><p>Referring to the above diagram, the workflow of establishing a Otter video call after the infrastructure has been deployed is as follows:</p><ol><li><p><strong>Create room resource</strong>: The developer adds functionality (ie a button) which sends a POST request to the /createRoom resource and a room link is generated and sent to the user.</p></li><li><p><strong>Load Otter Web App by visiting the room link</strong>: The Otter Web App is served from CloudFront.</p></li><li><p><strong>Validate room, get TURN credentials</strong>: The Otter Web App validates the room with a GET request to the /room/{id} resource and fetches the CoTURN credentials with a GET request to the /credentials resource.</p></li><li><p><strong>Connect with signaling server</strong>: The Otter Web App establishes a connection to the API WebSocket gateway.</p></li><li><p><strong>Request public IP address candidates</strong>: The Otter Web App starts gathering candidate IP addresses to send as messages to exchange offers and answers.</p></li><li><p>Now the video call between peers can commence.</p></li></ol><p>Otter not only reduces the overhead involved in the deployment and integration of the resources in the diagram above but also of these resource’s associated roles, policies, security groups, etc. In total, Otter ends up saving the developer over 100 steps with the creation and integration of all of these AWS resources and their associated entities.</p><h2 id=notes>Notes <a href=#notes class=anchor aria-hidden=true>#</a></h2><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Defining “real-time” could be an entire separate discussion. Here, real-time means anything less than 100ms, since this latency generally is low enough to be unnoticed by humans; <a href=https://yusufarslan.net/sites/yusufarslan.net/files/upload/content/Miller1968.pdf>1968 Paper by Robert Miller</a>.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://docs.expertflow.com/chat/3.18/hybrid-chat-deployment/turn-server-deployment-guide>TURN Server Deployment Guide</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div><div class="page-footer-meta d-flex flex-column flex-md-row justify-content-between"></div><div class="docs-navigation d-flex justify-content-between"><a href=https://otter-framework.dev/docs/case-study/introducing-otter/><div class="card my-1"><div class="card-body py-2">&larr; Introducing Otter</div></div></a><a class=ms-auto href=https://otter-framework.dev/docs/case-study/engineering-challenges/><div class="card my-1"><div class="card-body py-2">Engineering Challenges &rarr;</div></div></a></div></main></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Powered by <a class=text-muted href=https://www.netlify.com/>Netlify</a>, <a class=text-muted href=https://gohugo.io/>Hugo</a>, and <a class=text-muted href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline></ul></div></div></div></footer><script src=https://otter-framework.dev/js/bootstrap.min.87685cf4e6585276ff9e7b5d0b97e792615af6921e77821315d1ca7c5511ac2f30667e16c0d031e680ca8b57f63f6c0f6c4a232da777cce474b501ed81e090a9.js integrity="sha512-h2hc9OZYUnb/nntdC5fnkmFa9pIed4ITFdHKfFURrC8wZn4WwNAx5oDKi1f2P2wPbEojLad3zOR0tQHtgeCQqQ==" crossorigin=anonymous defer></script>
<script src=https://otter-framework.dev/js/highlight.min.56a414730f1135fe77b5ea30bf74a2cc4101a6f386e85e5b789c800570cc33d33054000f45932c053a59b41018f72687867254a80e1b9710671852492533162f.js integrity="sha512-VqQUcw8RNf53teowv3SizEEBpvOG6F5beJyABXDMM9MwVAAPRZMsBTpZtBAY9yaHhnJUqA4blxBnGFJJJTMWLw==" crossorigin=anonymous defer></script>
<script src=https://otter-framework.dev/main.min.48112dadd832db3af6d4d33366c964d3fbb9a6650b84f6a6bc5e79c3ba86d94a2e7fe3515d588ad342a14de3260a6ffd2f49830115f6213a7e3b563ff9de1801.js integrity="sha512-SBEtrdgy2zr21NMzZslk0/u5pmULhPamvF55w7qG2Uouf+NRXViK00KhTeMmCm/9L0mDARX2ITp+O1Y/+d4YAQ==" crossorigin=anonymous defer></script>
<script src=https://otter-framework.dev/index.min.794cea15a151943ac139a010f8e8f1346df09d06426abde8e0f91d9259af5efc841496ae66978203bff6472fa0b0bb98ada11d68948b52f8c431d7b813a9c78a.js integrity="sha512-eUzqFaFRlDrBOaAQ+OjxNG3wnQZCar3o4PkdklmvXvyEFJauZpeCA7/2Ry+gsLuYraEdaJSLUvjEMde4E6nHig==" crossorigin=anonymous defer></script><div class="d-flex fixed-bottom pb-4 pb-lg-5 pe-4 pe-lg-5"><a id=toTop href=# class="btn btn-outline-primary rounded-circle ms-auto p-2"><span class=visually-hidden>Top</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-up"><polyline points="18 15 12 9 6 15"/></svg></a></div></body></html>