var suggestions=document.getElementById("suggestions"),search=document.getElementById("search");search!==null&&document.addEventListener("keydown",inputFocus);function inputFocus(e){e.ctrlKey&&e.key==="/"&&(e.preventDefault(),search.focus()),e.key==="Escape"&&(search.blur(),suggestions.classList.add("d-none"))}document.addEventListener("click",function(e){var t=suggestions.contains(e.target);t||suggestions.classList.add("d-none")}),document.addEventListener("keydown",suggestionFocus);function suggestionFocus(e){const s=suggestions.classList.contains("d-none");if(s)return;const t=[...suggestions.querySelectorAll("a")];if(t.length===0)return;const n=t.indexOf(document.activeElement);if(e.key==="ArrowUp"){e.preventDefault();const s=n>0?n-1:0;t[s].focus()}else if(e.key==="ArrowDown"){e.preventDefault();const s=n+1<t.length?n+1:n;t[s].focus()}}(function(){var e=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:"id",store:["href","title","description"],index:["title","description","content"]}});e.add({id:0,href:"/docs/case-study/introduction/",title:"Introduction",description:`Otter is a drop-in, serverless solution that facilitates peer-to-peer video communication within web applications. It can be deployed to AWS with a single command, and is ideal for existing web applications with real-time video communication needs.
For an application developer, Otter abstracts away the complexity of establishing a resilient, scalable infrastructure, and provides a simple way to integrate peer-to-peer WebRTC video calling into an application.
In this case study, we will dive into Otter and explore how we built it and the design decisions and technical challenges we faced along the way.`,content:`Otter is a drop-in, serverless solution that facilitates peer-to-peer video communication within web applications. It can be deployed to AWS with a single command, and is ideal for existing web applications with real-time video communication needs.
For an application developer, Otter abstracts away the complexity of establishing a resilient, scalable infrastructure, and provides a simple way to integrate peer-to-peer WebRTC video calling into an application.
In this case study, we will dive into Otter and explore how we built it and the design decisions and technical challenges we faced along the way. We will begin with an overview of peer-to-peer (P2P) and WebRTC.
Why video calling? #It’s hard to imagine our modern world without it, and thus it\u0026rsquo;s no surprise that software developers are increasingly interested in incorporating it into their applications. In the last few years especially, the growth of telehealth has made video calling more commonplace in healthcare, though this is just one of many industries embracing video communication.
However, implementing reliable and scalable video communication comes with nuanced considerations, and developers need to consider several approaches to ensure that their solution is optimized for their end users. For example, selecting a network topology (how the various nodes of a network are arranged and connected) can have implications regarding the latency, resilience and even privacy of a network. Within this case study, we will discuss many of the tradeoffs a developer may need to consider, starting with the tradeoffs between two major network topologies: a peer-to-peer model versus a client-server model.
P2P vs Client-Server Network Topologies #P2P is a network topology in which devices communicate directly with each other without the need for a central server. In a P2P network, each device can act as both a client and a server, meaning that it can both send and receive data directly with other devices in the network.
By contrast, in a client-server network topology, devices connect to a centralized server, which manages communication between devices.
In the context of video communication, there are several benefits that a P2P topology brings over a traditional client-server network. Firstly, it provides privacy for the peers, as P2P networks eliminate the need for a central server that can log or monitor data passing through. In addition, P2P networks can decrease latency between peers. Without a central server, data has one less hop on the network before being sent to its destination, which can reduce the distance and time required to transmit information.
Having no centralized server can also make a network more resilient. Within a traditional client-server model, the server represents a single point of failure; if it goes down then peers cannot communicate. A P2P network, on the other hand, distributes the burden of transporting data across all peers in the network, rather than relying on dedicated servers.
The bandwidth consumed between peers is each peer’s individual responsibility, eliminating the need for a central server to consume any bandwidth. Thus, a P2P network can be more cost effective as a developer does not have to pay to provision and maintain dedicated servers, or the bandwidth they would consume.
Of course, P2P networks have their limitations, and in the context of a video call, the most notable limitation is call size. Let’s see what happens when more peers are added to the network.
In its simplest form, a P2P network requires that each peer connects to every other peer in the network1. Thus, in a P2P video call with 20 peers, each peer must send its video data in 19 different directions, and must process 19 separate incoming video streams from other peers! Larger call sizes quickly become untenable in terms of the bandwidth requirement placed on individual peers; a P2P video call may be able to support around 6 participants before performance is degraded.
A client-server topology is not limited in this way, since the central server manages video connections between other peers. Furthermore, introducing a centralized server can bring additional functionality to a video calling application, like the ability to record a call, or apply real-time effects such as closed captions, color correction or facial recognition.
A client-server model would be a more effective choice for a developer who needs to support call sizes of more than a few people, or needs additional features like the ability to record calls. This topology could make sense for a developer who wants to implement video conferencing for online classes, support large business meetings, or record video calls that can be reviewed later for training purposes.
However, for a developer working on an application where privacy is of the utmost importance, a P2P topology is a better fit. Telehealth calls and virtual legal consultations are situations where calls will contain sensitive information, and the privacy of these calls are even protected by law. Thus, the privacy gained by removing a central server (which can process and monitor these communications) is notable. Additionally, the private nature of these calls means that call sizes will usually never be larger than a few people.
Transport protocols in context of video calling #For the developer who wants to add P2P video calling to their web application, what else should be considered that may affect the user experience? Latency is a key aspect that can make video calls feel responsive and various methods of transporting media packets over the network can affect latency. Typically, media packets are transported through TCP (Transmission Control Protocol) or UDP (User Datagram Protocol).
TCP is a protocol designed to make data transmission across the network reliable. TCP is considered a connection-oriented protocol because every TCP connection has three well-defined phases, including a handshake which establishes the parameters for data transmission to come. Once the handshake is completed, packets can be sequenced and delivered in order, and if a packet is lost, it is retransmitted, thus providing a guarantee of delivery and a guarantee of in-order delivery. TCP also has built in control for network congestion avoidance by _delaying _packets if network congestion is detected. Both such guarantees and network congestion avoidance can increase the latency in transmission of real-time video.
On the other hand, UDP is a connectionless protocol, and can send data without having to first establish a connection. UDP does not offer reliability, and instead offers speed and flexibility. A few lost packets can be tolerated as long as the video stream remains uninterrupted, because having the latest data is more important than having all the data.
UDP is therefore ideal for rich audio and video data transmission, while TCP’s reliability mechanisms can introduce delays that are not conducive to a responsive audio-video user experience.
UDP-based, P2P Video Calling Solutions #What options exist for a developer who wants to add a UDP-based, P2P video calling solution to their web application?
It is possible for developers to build P2P video calling functionality by manually stitching together multiple protocols, like RTMFP (Real Time Media Flow Protocol) with SIP (Session Initiation Protocol). This could provide a high degree of customization, but at the expense of valuable time, as a developer would have to gain a deep understanding of multiple protocols and how they should interact together.
Another possible solution is WebRTC (Web Real Time Communication), which is both a collection of protocols and a communication standard used to implement P2P real-time communication. WebRTC is free and works natively within browsers. However, there can be compatibility issues between browsers, and a browser-based solution may not provide as much functionality as a solution implemented in a desktop app. Still, WebRTC has been widely adopted in many products and services, including Google Meet, Facebook Messenger and Discord.
A third possible solution is the SRT protocol (Secure Reliable Transport). It’s an open source UDP-based protocol, and since 2019 it has added P2P functionality with HTML5 browser support. However, SRT is focused more on high-quality live streaming rather than low latency video calling. Specifically, SRT adds error correction mechanisms that reduce packet loss, but at the cost of increased latency, so for real-time video calling it\u0026rsquo;s not a perfect fit. Since this technology is very new, there is not much documentation on how to implement this technology, or a long track record of success yet.
WebRTC is a strong candidate for a developer looking to integrate a UDP-based, P2P video calling solution into a web application. In addition to working natively in all major modern browsers, WebRTC greatly simplifies the complexity of having to implement real-time functionality for the developer. WebRTC orchestrates protocols to bypass restrictive network environments, encrypt application data end-to-end, use reliable communication channels on top of UDP, process media streams, and more.
Implementing real-time P2P functionality will be much more straightforward with WebRTC than without, but there is still a depth of knowledge required for working with WebRTC. We will touch on this essential knowledge next.
Notes #There are additional P2P topologies, but these are beyond the scope of this case study\u0026#160;\u0026#x21a9;\u0026#xfe0e;
`}),e.add({id:1,href:"/docs/case-study/web-rtc/",title:"How WebRTC Works",description:`How do peers connect? #Let’s look at a high-level workflow of how a direct connection can be established between two peers. We will use an analogy of a peer Alice sending physical mail to another peer Bob.
How does Alice know where to address her mail to?
Alice will need some mechanism to exchange addresses with Bob to facilitate the delivery, which is known as signaling. This could be a text message or even a pigeon carrier.`,content:`How do peers connect? #Let’s look at a high-level workflow of how a direct connection can be established between two peers. We will use an analogy of a peer Alice sending physical mail to another peer Bob.
How does Alice know where to address her mail to?
Alice will need some mechanism to exchange addresses with Bob to facilitate the delivery, which is known as signaling. This could be a text message or even a pigeon carrier. In practice, this is typically facilitated by a server.
Let’s suppose Alice and Bob are in the same building. All communication passes via the signaling mechanism. Alice informs Bob that she is interested in sending him mail but she needs his room number. Bob responds with this information and Alice is then able to deliver the mail directly.
While this is ideal, what happens if Alice is actually in a different building than Bob?
Alice and Bob may know each other’s room number, but this information is rather useless outside of their respective buildings unless they also know their respective building addresses. To find their respective building addresses, they can each ask their building doorman.
Now with a building address and room number, they can communicate this information using the same signaling mechanism. Alice can visit Bob’s building and deliver the mail herself directly.
What if Alice is traveling and ends up in a different city, state or country than Bob?
In this case, Alice is not able to directly deliver the mail to Bob herself, so she must resort to delegating the delivery work to a courier.
To summarize our analogy, there are up to three possible methods for Alice and Bob to exchange addresses and connect. Each requires a different approach. Mapping this analogy to WebRTC, a signaling server and other servers (i.e. the building doorman and courier) are required in order to reliably establish a WebRTC connection. Next, we will take a more technical look at these components and discuss how they work together.
Technical Discussion #Signaling Server #The sole responsibility of a signaling server is to relay messages between peers who wish to connect. This relay allows peers to exchange critical information required to establish a direct P2P connection. However, the WebRTC specification does not actually describe how to implement a signaling server. Instead, the implementation details are left to the developer, since an existing backend infrastructure (serving some other purpose) could also be utilized as the signaling server.
The structure of the information relayed is governed by the Session Description Protocol (SDP), a simple key-value text-based protocol. Some of the information contained within the SDP includes:
The IP addresses through which each peer can be reached The media streams, either audio, video, or both, that each peer wishes to send to the other peer The different codecs available to both peers to encode and decode the media streams In WebRTC terminology, initializing a call requires peer A to send an “offer” to peer B who responds with an “answer”. The offer and answer represent each peer’s respective session description. With this information a direct P2P connection can be established.
This exchange of session descriptions occurs during the initial phase of the call, but also any time the state of the session changes. If a peer decides to send a new media stream or begins experiencing network issues, a new “offer” and “answer” will be dispatched between the peers through the signaling channel. It is therefore not uncommon to have multiple negotiation phases between peers during a single session. The ability of the underlying application to handle this uncertainty regarding the state of the session is crucial in providing a seamless user experience. This is easier said than done, which we will explore when discussing the engineering challenges that we faced while building Otter.
Network Address Translation #One of the fundamental rules for all communication over the Internet is that every participating host must be assigned a public IP address. Under IPv4, an IP address represents a sequence of 32 bits divided into 4 octets of 8 bits each, which means that every octet has 2^8, or 256, possibilities. Therefore, there is an upper bound of ~4.3 billion on the total number of IPv4 addresses available in the world. With the ever increasing number of devices connected to the Internet, engineers realized that this upper bound would be reached sooner than expected. To address this issue, Network Address Translation (NAT) was proposed.
The NAT solution allows hosts within a private network to share a pool of public IP addresses to communicate over the Internet. For example, an internal host who wishes to send a message over the Internet will first send it to their NAT device (i.e. a router), which will then change the source IP address on the packet to a public IP address chosen from its pool of available IP addresses. The NAT device keeps track of which hosts are currently assigned a public IP address to be able to route messages from the Internet to the appropriate internal host. Even though NAT did address some problems related to the availability of IP addresses, it also created new ones for UDP traffic.
Recall every TCP connection has a well-defined communication flow. NAT devices rely on this underlying flow to determine when a connection is first established and when it is closed. This allows a NAT device to do the following:
During the exchange to open a connection, assign a public IP address to an internal host for the lifetime of the connection (i.e., the NAT device creates a private/public IP address mapping for the host) During the exchange of application data, route messages between the internal and external hosts During the exchange to close the connection, remove the assigned public IP address and make it available to other internal hosts UDP, on the other hand, is connectionless. Unpredictable connection state is a major issue for NAT devices as they can no longer rely on the underlying communication flow to manage outbound and inbound packets appropriately. This makes it difficult for internal hosts to maintain a stable communication channel with external hosts. Since WebRTC relies on UDP, how does it resolve the missing connection state?
STUN \u0026amp; TURN Servers #The answer lies within the fact that both peers need a public IP address. Like the room numbers inside the different buildings, a private IP address is useless outside of its private network. The solution, a Session Traversal Utilities for NAT (STUN) server.
A STUN server allows hosts within a private network to programmatically create a mapping in the routing table of the NAT device. The response of the STUN server will include a header indicating the IP address and port of the NAT mapping. STUN also periodically sends empty messages through the NAT device, which benefits UDP traffic by keeping the NAT mapping and thus connection state alive. This mapping can be relayed to the other peer through the signaling channel. Both peers now have a public IP address.
Connecting…
Not so fast! There are still situations where the above is not sufficient. When a NAT device creates a mapping within its routing table, it becomes responsible for routing outbound and inbound packets for the mapping. The way that inbound packets are routed and filtered can vary depending on the NAT device and its configuration.
In any case, inbound packets that are not allowed to use a specific mapping in the routing table are simply discarded by the NAT device. Depending on the filtering behavior of the NAT devices, communication between peers by using IP addresses and ports obtained through STUN servers may not be possible.
Furthermore, even if the NAT devices are not obstacles to a direct connection, private network firewalls can be. Firewalls can block traffic from certain port ranges or even block UDP traffic altogether. Analogous to how a courier helped Alice delegate her delivery, a workaround will be needed to establish a connection. The solution, a Traversal Using Relays around NAT (TURN) server.
If all else fails, a TURN server will act as a middleman between the peers. A peer that requires its packets to be relayed can simply send them to the TURN server. The TURN server then “dumbly” relays the packets to the other peer, without concern for its contents. The other peer is not aware that the packets are now being relayed.
Using a TURN server is a last resort as it adds latency to the communication and increases the operating costs of the system due to the significant bandwidth usage. However, to allow a seamless user experience, it is a required component of the overall infrastructure. In reality, the aforementioned scenario requiring a TURN server only affects a small percentage of end users. According to Google1:
92% of the time the connection can take place directly (STUN). 8% of the time the connection requires a relay (TURN). In summary, a successful connection requires both peers to gather multiple IP address and port pairs through which they could potentially be reached. In WebRTC terminology, a pair is known as a “candidate transport address”. These candidates are then exchanged between peers through the signaling channel. All possible combinations of candidates from both peers are then tested for connectivity establishment (i.e., if both peers have 3 candidates, 9 possible routes will be tested). Determining the most efficient path between peers on the network is critical and justifies the need for a STUN and TURN server in a WebRTC P2P topology.
Existing solutions #WebRTC is a flexible solution for P2P real-time communication, but the trade off of this flexibility is that a developer has to deal with the complexity of implementing critical components such as signaling and STUN/TURN servers. In addition, another layer of complexity is introduced when working with the WebRTC API.
To implement a P2P WebRTC solution, developers can take the DIY route and stitch together existing open-source solutions (PeerJS, CoTURN etc). However, the developer would still need to configure and maintain all the necessary infrastructure to host their solution.
On the other hand, there are commercial solutions like the Twilio SDK or Vonage SDK that make WebRTC easier to work with. They are easy to use and provide many features. However they are not free and are not private in the sense that session data is kept within their infrastructure.
After examining the available options, we realized that there was a gap between the open-source and commercial solutions. While the open-source options are effective, they can be challenging and time-consuming to implement. Conversely, the commercial options are user-friendly but come with a significant cost.
As a result, we chose to develop a simplified open-source alternative to Twilio that would be easy to deploy and scale, addressing the gaps we found in the existing open-source solutions. However, we had to make a trade-off between simplicity and functionality, so our solution focuses mainly on core video call features, and doesn\u0026rsquo;t offer many additional features beyond that.
Notes #High Performance Browser Networking: What every web developer should know about networking and web performance\u0026#160;\u0026#x21a9;\u0026#xfe0e;
`}),e.add({id:2,href:"/docs/case-study/",title:"Case Study",description:"Otter Case Study",content:""}),e.add({id:3,href:"/docs/documentations/",title:"Documentations",description:"Otter Documentations",content:""}),e.add({id:4,href:"/docs/documentations/quick-start/",title:"Quick Start",description:"One page summary of how to start a new Doks project.",content:`Requirements #Git — latest source release Node.js — latest LTS version or newer Why Node.js?Doks uses npm (included with Node.js) to centralize dependency management, making it easy to update resources, build tooling, plugins, and build scripts. Start a new Doks project #Create a new site, change directories, install dependencies, and start development server.
Create a new site #Doks is available as a child theme and a starter theme.
Child theme #Intended for novice to intermediate users Intended for minor customizations Easily update npm packages — including Doks git clone https://github.com/h-enk/doks-child-theme.git my-doks-site Starter theme #Intended for intermediate to advanced users Intended for major customizations Easily update npm packages git clone https://github.com/h-enk/doks.git my-doks-site Help me chooseNot sure which one is for you? Pick the child theme. Change directories #cd my-doks-site Install dependencies #npm install Start development server #npm run start Doks will start the Hugo development webserver accessible by default at http://localhost:1313. Saved changes will live reload in the browser.
Other commands #Doks comes with commands for common tasks. Commands →
`}),e.add({id:5,href:"/docs/documentations/commands/",title:"Commands",description:"Doks comes with commands for common tasks.",content:`💡 You can change the commands in the scripts section of \`./package.json\`. create #Create new content for your site:
npm run create [path] [flags] See also the Hugo docs: hugo new.
Docs based tree #Create a docs based tree — with a single command:
npm run create -- --kind docs [section] For example, create a docs based tree named guides:
npm run create -- --kind docs guides lint #Check scripts, styles, and markdown for errors:
npm run lint scripts #Check scripts for errors:
npm run lint:scripts [-- --fix] styles #Check styles for errors:
npm run lint:styles [-- --fix] markdown #Check markdown for errors:
npm run lint:markdown [-- --fix] clean #Delete temporary directories:
npm run clean start #Start local development server:
npm run start build #Build production website:
npm run build functions #Build Lambda functions:
npm run build:functions preview #Build production website including draft and future content:
npm run build:preview `}),e.add({id:6,href:"/docs/documentations/how-to-update/",title:"How to Update",description:"Regularly update the installed npm packages to keep your Doks website stable, usable, and secure.",content:`💡 Learn more about semantic versioning and advanced range syntax. Check for outdated packages #The npm outdated command will check the registry to see if any (or, specific) installed packages are currently outdated:
npm outdated [[\u0026lt;@scope\u0026gt;/]\u0026lt;pkg\u0026gt; ...] Update packages #The npm update command will update all the packages listed to the latest version (specified by the tag config), respecting semver:
npm update [\u0026lt;pkg\u0026gt;...] `}),e.add({id:7,href:"/docs/documentations/troubleshooting/",title:"Troubleshooting",description:"Solutions to common problems.",content:`Problems updating npm packages #Delete the ./node_modules folder, and run again:
npm install Problems with cache #Delete the temporary directories:
npm run clean `}),e.add({id:8,href:"/docs/documentations/otter-api/",title:"Otter API",description:"Otter API Documentation",content:""}),e.add({id:9,href:"/docs/",title:"Docs",description:"Docs Doks.",content:""}),search.addEventListener("input",t,!0);function t(){const s=5;var n=this.value,o=e.search(n,{limit:s,enrich:!0});const t=new Map;for(const e of o.flatMap(e=>e.result)){if(t.has(e.doc.href))continue;t.set(e.doc.href,e.doc)}if(suggestions.innerHTML="",suggestions.classList.remove("d-none"),t.size===0&&n){const e=document.createElement("div");e.innerHTML=`No results for "<strong>${n}</strong>"`,e.classList.add("suggestion__no-results"),suggestions.appendChild(e);return}for(const[r,a]of t){const n=document.createElement("div");suggestions.appendChild(n);const e=document.createElement("a");e.href=r,n.appendChild(e);const o=document.createElement("span");o.textContent=a.title,o.classList.add("suggestion__title"),e.appendChild(o);const i=document.createElement("span");if(i.textContent=a.description,i.classList.add("suggestion__description"),e.appendChild(i),suggestions.appendChild(n),suggestions.childElementCount==s)break}}})()